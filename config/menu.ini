var Menu, Pause;

function GUIInit() {
  Menu = new GUI({
    createNode: function(data, params) {
      var fragment = document.createElement("span"),
          space = document.createTextNode("\u00A0"),
          speedText = document.createElement("span"),
          br = document.createElement("br"),
          speedNode = document.createElement("span"),
          intervals = [], that = this;
      data.pressAny = document.createElement("span");

      data.speed = {
        decrease: function() {
          speedNode[textContent] =
            "0" + (--speed);
          data.applyColors();
        },
        increase: function() {
          speedNode[textContent] =
            (++speed === 10?"":"0") + speed;
          data.applyColors();
        },
        record: function() {
          if(speed !== speeds[1])
            storage.setItem("speed", speed);
          else storage.removeItem("speed", speed);
        }
      };

      data.listen = function(keyCode) {
        switch(keyCode) {
          case 0:
          case 3:
            if(speed > speeds[0])
              data.speed.decrease();
              if(storage)
                data.speed.record(); break;
          case 1:
          case 2:
            if(speed < speeds[2])
              data.speed.increase();
              if(storage)
                data.speed.record(); break;
          case 4:
            that.hide();
        }
      };

      data.listener = new Listener(
        [left, up, right, down, enter],
        true,
        data.listen
      );

      data.applyColors = function(resetEffects) {
        var color = Graphics.TextGlowEffects?[]:undefined;
        if(speed > speeds[0]) {
          if(Graphics.Transparency) setOpacity(data.left, ((speed - speeds[0]) / (speeds[2] - speeds[0])) * 100);
          else {
            if(covered(data.left)) uncover(data.left);
            else if(resetEffects) setOpacity(data.left, 100);
          }
        }
        else {
          clearInterval(intervals[0]);
          cover(data.left);
        }
        if(speed < speeds[2]) {
          if(Graphics.Transparency) setOpacity(data.right, (1 - (speed - speeds[0]) / (speeds[2] - speeds[0])) * 100);
          else {
            if(covered(data.right)) uncover(data.right);
            else if(resetEffects) setOpacity(data.right, 100);
          }
        }
        else {
          clearInterval(intervals[1]);
          cover(data.right);
        }

        if(speed === speeds[0]) {
          if(Graphics.TextGlowEffects) {
            color      = speedColors[0];
          } else color = speedColors[0][0];
        } else if(speed > speeds[0] && speed < speeds[1]) {
          if(Graphics.TextGlowEffects) {
            color[0]   = data.colorTransitions[0].calc((speed - speeds[0]) / (speeds[1] - speeds[0]));
            color[1]   = data.colorTransitions[2].calc((speed - speeds[0]) / (speeds[1] - speeds[0]));
          } else color = data.colorTransitions[0].calc((speed - speeds[0]) / (speeds[1] - speeds[0]));
        } else if(speed === speeds[1]) {
          if(Graphics.TextGlowEffects) {
            color      = speedColors[1];
          } else color = speedColors[1][0];
        } else if(speed > speeds[1] && speed < speeds[2]) {
          if(Graphics.TextGlowEffects) {
            color[0]   = data.colorTransitions[1].calc((speed - speeds[1]) / (speeds[2] - speeds[1]));
            color[1]   = data.colorTransitions[3].calc((speed - speeds[1]) / (speeds[2] - speeds[1]));
          } else color = data.colorTransitions[1].calc((speed - speeds[1]) / (speeds[2] - speeds[1]));
        } else {
          if(Graphics.TextGlowEffects) {
            color      = speedColors[2];
          } else color = speedColors[2][0];
        }

        speedNode.style.color = Graphics.TextGlowEffects?color[0]:color;
        if(Graphics.TextGlowEffects)
          setGlow(speedNode, GlowMagnitude, color[1]);
        else if(resetEffects)
          setGlow(speedNode, 0, color[1]);
      }

      if(Graphics.Transparency)
        data.anim = function(visible) {
          data.clearAnim = retransparent(
            data.pressAny,
            1000,
            visible?100:30,
            visible?30:100,
            function() {
              data.anim(!visible);
            }
          );
        };

      data.scoreObj = new ScoreNode;
      data.scoreHidden = true;
      data.scoreNode = data.emptyScoreNode = document.createTextNode("");
      data.fullScoreNode = (function() {
        var node = document.createDocumentFragment(),
            score = data.scoreObj.node,
            brWrapper = document.createElement("span"),
            br = document.createElement("br");
        brWrapper.style.fontSize = length * drawTextMultiplier * 0.4;
        brWrapper.appendChild(br.cloneNode(false));
        node.appendChild(score);
        node.appendChild(br);
        node.appendChild(brWrapper);
        return node;
      })();
      speedText[textContent] = l[0];
      speedText.style.fontVariant =
      data.pressAny.style.fontVariant = "small-caps";
      data.pressAny[textContent] = l[2];
      speedNode[textContent] = (speed === 10?"":"0") + speed;
      data.left = document.createElement("span");
      data.right = document.createElement("span");
      data.left[textContent] = "<";
      data.right[textContent] = ">";
      data.left.style.color = data.right.style.color = sTextColors[4][0];
      data.left.style.cursor = data.right.style.cursor = "pointer";
      data.left.onselectstart = right.onselectstart = function(e) {
      e = e || event;
      e.returnValue = false;
      return false;
      };
      data.left.onmousedown = function(e) {
        intervals[0] = setInterval(function() {
          data.listen(0);
        }, 80);
        e = e || event;
        e.returnValue = false;
        return !!data.listen(0);
      };
      data.left.onmouseup = function(e) {
        clearInterval(intervals[0]);
        e = e || event;
        e.returnValue = false;
        return false;
      };
      data.right.onmousedown = function(e) {
        intervals[1] = setInterval(function() {
          data.listen(1);
        }, 100);
        e = e || event;
        e.returnValue = false;
        return !!data.listen(1);
      };
      data.right.onmouseup = function(e) {
        clearInterval(intervals[1]);
        e = e || event;
        e.returnValue = false;
        return false;
      };
      if(Graphics.TextGlowEffects) {
        setGlow(data.left, GlowMagnitude, sTextColors[4][1]);
        setGlow(data.right, GlowMagnitude, sTextColors[4][1]);
      }
      data.colorTransitions = [
        new colorTransition(speedColors[0][0], speedColors[1][0]),
        new colorTransition(speedColors[1][0], speedColors[2][0]),
        new colorTransition(speedColors[0][1], speedColors[1][1]),
        new colorTransition(speedColors[1][1], speedColors[2][1])
      ];
      data.applyColors();
      fragment.style.fontSize = (drawTextMultiplier * length) + "px";
      fragment.style.color = sTextColors[0][0];
      if(Graphics.TextGlowEffects) {
        setGlow(fragment, GlowMagnitude, sTextColors[0][1]);
        setGlow(data.left, GlowMagnitude, sTextColors[4][1]);
        setGlow(data.right, GlowMagnitude, sTextColors[4][1]);
      }
      fragment.appendChild(data.scoreNode);
      fragment.appendChild(speedNode);
      fragment.appendChild(data.left);
      fragment.appendChild(space.cloneNode(false));
      fragment.appendChild(speedText);
      fragment.appendChild(speedNode);
      fragment.appendChild(space.cloneNode(false));
      fragment.appendChild(data.right);
      fragment.appendChild(br);
      fragment.appendChild(data.pressAny);
      return fragment;
    },
    updateColors: function(node, params, data) {
      var resetEffects = params[0];
      data.colorTransitions = [
        new colorTransition(speedColors[0][0], speedColors[1][0]),
        new colorTransition(speedColors[1][0], speedColors[2][0]),
        new colorTransition(speedColors[0][1], speedColors[1][1]),
        new colorTransition(speedColors[1][1], speedColors[2][1])
      ];
      data.left.style.color = sTextColors[4][0];
      data.right.style.color = sTextColors[4][0];
      node.style.color = sTextColors[0][0];
      if(Graphics.TextGlowEffects) {
        setGlow(node, GlowMagnitude, sTextColors[0][1]);
        setGlow(data.left, GlowMagnitude, sTextColors[4][1]);
        setGlow(data.right, GlowMagnitude, sTextColors[4][1]);
      } else if(resetEffects) {
        setGlow(node, 0, sTextColors[0][1]);
        setGlow(data.left, 0, sTextColors[4][1]);
        setGlow(data.right, 0, sTextColors[4][1]);
      }
      if(resetEffects) {
        if(data.clearAnim) data.clearAnim();
        if(!Graphics.Transparency && getOpacity(data.pressAny) !== 100) {
          setOpacity(data.pressAny, 100);
        } else if(this.status !== GUI.HIDDEN &&
                  this.status !== GUI.HIDING) data.anim(true);
      }
      data.applyColors(resetEffects);
      data.scoreObj.update(true);
    },
    hideCalled: function(node, additionalAttributes, data) {
      data.listener.stopListening();
      if(data.callback && !switchingModes) data.callback();
    },
    hideNode: function(node, additionalAttributes, data) {
      if(data.clearAnim) data.clearAnim();
    },
    showNode: function(node, additionalAttributes, data) {
      if(additionalAttributes && additionalAttributes.callback !== undefined)
        data.callback = additionalAttributes.callback;
      data.listener.startListening();
      if(Graphics.Transparency) data.anim(true);
      if(additionalAttributes && additionalAttributes.showScore !== undefined) {
        if(additionalAttributes.showScore)
          data.scoreObj.update();
        if(data.scoreHidden && additionalAttributes.showScore) {
          node.replaceChild(data.fullScoreNode, data.emptyScoreNode);
          data.scoreHidden = false;
        } else if(!data.scoreHidden && !additionalAttributes.showScore) {
          node.replaceChild(data.emptyScoreNode, data.fullScoreNode);
          data.scoreHidden = true;
        }
      }
    }
  });
  Pause = new GUI({
    createNode: function(data) {
      data.scoreObj = new ScoreNode;
      var fragment = document.createElement("span"),
          header = document.createTextNode(l[5]),
          br = document.createElement("br"),
          score = data.scoreObj.node;
      data.twiddle = document.createElement("span");
      data.twiddle[textContent] = "~";
      data.twiddle.style.color = sTextColors[5][0];
      fragment.style.fontSize = (drawTextMultiplier * length) + "px";
      fragment.style.color = sTextColors[0][0];
      if(Graphics.TextGlowEffects) {
        setGlow(fragment, GlowMagnitude, sTextColors[0][1]);
        setGlow(data.twiddle, GlowMagnitude, sTextColors[5][1]);
      }
      data.twinTwiddle = data.twiddle.cloneNode(true);
      fragment.appendChild(data.twiddle);
      fragment.appendChild(header);
      fragment.appendChild(data.twinTwiddle);
      fragment.appendChild(br);
      fragment.appendChild(score);
      return fragment;
    },
    showNode: function(node, attributes, data) {
      data.scoreObj.update();
    },
    updateColors: function(node, params, data) {
      var formerTwinTwiddle = data.twinTwiddle,
          resetEffects = params[0];
      data.scoreObj.update(resetEffects);
      node.style.color = sTextColors[0][0];
      data.twiddle.style.color = sTextColors[5][0];
      if(Graphics.TextGlowEffects) {
        setGlow(node, GlowMagnitude, sTextColors[0][1]);
        setGlow(data.twiddle, GlowMagnitude, sTextColors[5][1]);
      } else if(resetEffects) {
        setGlow(node, 0, sTextColors[0][1]);
        setGlow(data.twiddle, 0, sTextColors[5][1]);
      }
      data.twinTwiddle = data.twiddle.cloneNode(true);
      node.replaceChild(data.twinTwiddle, formerTwinTwiddle);
    }
  });
};

/*
  Používané atributy:
    Jak Menu, tak Pause: updateColors(true); -> Rozšířený update efektů, případné vypnutí (použité při změně grafického nastavení)
    U Menu: GUI.prototype.show: function(callback, additionalAttributes)
            -> showNode: function(node, additionalAttributes, data) -> additionalAttributes.callback - zavolá se po zavření menu
*/